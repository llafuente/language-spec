The std::allocator class template is the default Allocator used by all standard library containers if no user-specified allocator is provided. The default allocator is stateless, that is, all instances of the given allocator are interchangeable, compare equal and can deallocate memory allocated by any other instance of the same allocator type.

/*
Defines allocation/deallocation functions.
*/
struct allocator<$t> {
	// XXX REVIEW this is fun to parse ?! even possible!?
	// function () return type name <-- so strange!
	
	/*
	Allocates uninitialized continuos memory of given size
	*/	
	function (size s) lend uninitialized ref<$t> alloca

	/*
	Allocates continuos memory of given size initialized to zero
	
	Type system should test if the memory requires to be initialized based on the $t
	$t is primitive, zero is valid
	$t is struct, zero is invalid, force to call constructor before use
	*/
	function (size s) lend uninitialized ref<$t> calloca

	/*
	Deallocates memory

	Remarks:
		Eats memory because it doesn't lend anything!
	*/
	function (own ref<$t> ptr) void dealloca


	// EXPERIMENTAL
	/*
	Allocates aligned uninitialized continuos memory of given size
	*/
	// function (size s, size alignament) lend uninitialized ref<$t> aalloca

}

interface allocable {
	allocator _allocator = null
}
/*
It's the default allocator.
*/
const global allocator<i8> global_allocator = {
	function (size s) lend uninitialized ref<i8> {
		return libc.malloc(s)
	},
	// function (size s, size alignament) lend uninitialized ref<i8> {
	// 	return libc.malloc(s) // TODO
	// },
	function (size s) lend uninitialized ref<i8> {
		return libc.calloc(s)
	},
	function (own ref<i8> ptr) void {
		libc.free(ptr)
	}
}
/*
Holds the current default allocator.

When a core function needs to allocate memory and no allocator is sent, the default_allocator will be used.
*/
var global allocator<i8> default_allocator = global_allocator