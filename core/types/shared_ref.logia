// https://en.cppreference.com/w/cpp/memory/shared_ptr
// https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared
// https://doc.rust-lang.org/book/ch15-04-rc.html
// https://doc.rust-lang.org/src/alloc/rc.rs.html#317-320
// https://doc.rust-lang.org/std/ops/trait.Deref.html

package core.types.shared_ref "0.0.0"

import core.types.ref
import core.allocator

// single allocation data
type _smart_pointer_data<$t> = struct {
	$t data = $t.default
	allocator.dealloca dealloca = null
	size strong_count = 1
	size weak_count = 0
}


// noone owns this memory, exclusively

type _shared_ref_common<$t> = struct {
	ref<_smart_pointer_data<$t>> spointer

	/*
	Points the same data ?
	*/
	operator == (ref<weak_ref<$t>> other) bool {
		return @this!.sptr.data == @other.data
	}
	/*
	Points the same data ?
	*/
	operator == (ref<shared_ref<$t>> other) bool {
		return @this!.sptr.data == @other.data
	}

	function count() size {
		return this!.sptr.strong_count
	}

	function weak_count() size {
		return this!.sptr.weak_count
	}
}

/*
Smart pointer that holds a owning reference to an object.

Memory won't be freed until all strong and weak references are deleted.

Memory is valid while strong references exists.
*/
type shared_ref<$t> = struct extends _shared_ref_common<$t> {
	// default, empty constructor
	new() {
		return this.new($t.default)
	}
	// Copy constructor
	new($t t) {
		this!.sptr = new()
		// TODO ??
		pointer._dealloca = default_allocator.dealloca
		return this!.sptr.data
	}

	delete() {
		--this!.sptr.strong_count
		if (this!.sptr!.weak_count == 0 && this!.sptr!.strong_count == 0) {
			delete this!.sptr
		}
	}

	clone () {
		var x = new weak_ref<$t>(this)
		x.data = pointer.data
		++pointer.strong_count
	}
	/*
	Fowards member access operator to hold data type.
	*/
	operator .() $t {
		return pointer.data
	}

	/*
	Copy constructor from shared_ref
	*/
	operator = (ref<shared_ref<$t>> other) {
		if (pointer != null) { // can this happens ?
			this.delete()
		}
		pointer = other.pointer
		++pointer.strong_count
	}
	/*
	Copy constructor from weak_ref
	*/
	operator = (ref<weak_ref<$t>> other) {
		if (pointer != null) { // can this happens ?
			this.delete()
		}
		pointer = other.pointer
		++pointer.strong_count
	}
}
/*
Smart pointer that holds a non-owning ("weak") reference to an object that is managed by shared_ref.

To access shared data safe dereference operator (?.) shall be used.

*/
type weak_ref<$t> = struct extends _shared_ref_common<$t, None> {
	new(ref<sharef_ref<$t>> sr) {
		pointer = sr.pointer
		++pointer.weak_count
	}

	new(ref<weak_ref<$t>> wr) {
		pointer = wr.pointer
		++pointer.weak_count
	}

	delete() {
		--pointer.weak_count
		if (pointer.weak_count == 0 && pointer.strong_count == 0) {
			delete pointer
		}
	}

	clone () {
		var x = new weak_ref<$t>(this)
		x.data = pointer.data
		++pointer.weak_count
	}

	operator?.() {
		return pointer.data
	}
	/*
	Copy constructor from shared_ref
	*/
	new (ref<shared_ref<$t>> other) {
		if (pointer != null) { // can this happens ?
			this.delete()
		}
		pointer = other.pointer
		++pointer.weak_count
	}
	/*
	Copy constructor from weak_ref
	*/
	new (ref<weak_ref<$t>> other) {
		if (pointer != null) { // can this happens ?
			this.delete()
		}

		pointer = other.pointer
		++pointer.weak_count
	}

	function expired() {
		return !this.valid()
	}

	function valid() {
		return pointer.strong_count != 0
	}

	function lock() shared_ref<$t>? {
		if (pointer.strong_count != 0) {
			var p = cast<shared_ref<$t>>pointer.allocator.alloca(shared_ref<$t>.sizeof)
			p.pointer = pointer
			++pointer.strong_count
			return p
		}

		return null
	}
}

test shared_ref {
	#assert(shared_ref<i64>.size == ref.size)
	#assert(shared_ref<i32>.size == ref.size)

	#assert(_smart_pointer_data<i32>.size == size.size + i32.size)
	#assert(_smart_pointer_data<i64>.size == size.size + i64.size)

	var x = shared_ref<i64>(101)
	#assert(x == 101)
	
}
